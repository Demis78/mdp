---
title: "MDPs with external processes"
author: "Lars Relund <lars@relund.dk>"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{MDPs with external processes}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r ini, echo=FALSE, results='hide', message=FALSE}
library(MDP2)
library(knitr)
opts_knit$set(width=90, formatR.arrow=F, concordance=TRUE, global.par=TRUE)
#options(width = 120)
par(mar=c(0,0,0,0))
opts_chunk$set(out.width='100%', fig.width=15, fig.height=7, fig.path='graphic/', fig.align='center', fig.show='hold')
```

In this vignette we give an example of a small HMDP with external processes. First we generate the full HMDP without external processes.

```{r HMDP, tidy=FALSE}
# function for creating subprocess proc1
Proc1<-function(jumpActions=TRUE) {
   w$process()
      w$stage()   # stage n=0
         w$state(label="good")         
            w$action(label="mt", weights=c(55,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(70,1), prob=c(1,0,0.6, 1,1,0.4), end=TRUE)
         w$endState()
         w$state(label="average")        
            w$action(label="mt", weights=c(40,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(50,1), prob=c(1,1,0.6, 1,2,0.4), end=TRUE)
         w$endState()
      w$endStage()
      w$stage()   # stage n=1
         w$state(label="good")        
            if (jumpActions) w$action(label="rep", weights=c(30,1), prob=c(0,0,1), end=TRUE)
         w$endState()
         w$state(label="average")     
            if (jumpActions) w$action(label="rep", weights=c(10,1), prob=c(0,0,1), end=TRUE)
         w$endState()
         w$state(label="not working") 
            if (jumpActions) w$action(label="rep", weights=c(5,1), prob=c(0,0,1), end=TRUE)
         w$endState()
      w$endStage()
   w$endProcess()
}


# function for creating subprocess proc2
Proc2<-function(jumpActions=TRUE) {
   w$process()
      w$stage()   # stage n=0
         w$state(label="Dummy")          
            w$action(label="buy", weights=c(-100,1), prob=c(1,0,0.7, 1,1,0.3), end=TRUE)
         w$endState()
      w$endStage()
      w$stage()   # stage n=1
         w$state(label="good")           
            w$action(label="mt", weights=c(55,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(70,1), prob=c(1,0,0.6, 1,1,0.4), end=TRUE)
         w$endState()
         w$state(label="average")        
            w$action(label="mt", weights=c(40,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(50,1), prob=c(1,1,0.6, 1,2,0.4), end=TRUE)
         w$endState()
      w$endStage()
      w$stage()   # stage n=2
         w$state(label="good")          
            w$action(label="mt", weights=c(55,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(70,1), prob=c(1,0,0.5, 1,1,0.5), end=TRUE)
         w$endState()
         w$state(label="average")        
            w$action(label="mt", weights=c(40,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(50,1), prob=c(1,1,0.5, 1,2,0.5), end=TRUE)
         w$endState()
         w$state(label="not working")    
            w$action(label="mt", weights=c(30,1), prob=c(1,0,1), end=TRUE)
            w$action(label="rep", weights=c(5,1), prob=c(1,2,1), end=TRUE)    
         w$endState()
      w$endStage()
      w$stage()   # stage n=3
         w$state(label="good")          
            w$action(label="mt", weights=c(55,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(70,1), prob=c(1,0,0.2, 1,1,0.8), end=TRUE)
         w$endState()
         w$state(label="average")        
            w$action(label="mt", weights=c(40,1), prob=c(1,0,1), end=TRUE)
            w$action(label="nmt", weights=c(50,1), prob=c(1,1,0.2, 1,2,0.8), end=TRUE)
         w$endState()
         w$state(label="not working")    
            w$action(label="mt", weights=c(30,1), prob=c(1,0,1), end=TRUE)
            w$action(label="rep", weights=c(5,1), prob=c(1,1,1), end=TRUE)
         w$endState()
      w$endStage() 
      w$stage()   # stage n=4
         w$state(label="good")        
            if (jumpActions) w$action(label="rep", weights=c(30,1), prob=c(0,1,1), end=TRUE)   
         w$endState()
         w$state(label="average")     
            if (jumpActions) w$action(label="rep", weights=c(10,1), prob=c(0,1,1), end=TRUE)
         w$endState()
         w$state(label="not working") 
            if (jumpActions) w$action(label="rep", weights=c(5,1), prob=c(0,1,1), end=TRUE)
         w$endState()
      w$endStage()
   w$endProcess()
}

# build the HMDP (without external processes)
prefix<-"hmdp_"
w<-binaryMDPWriter(prefix)
w$setWeights(c("Reward","Time"))
w$process() # founder process with a single state
   w$stage()
      w$state(label="M0")
         w$action(label="A0",weights=c(0,1),prob=c(2,0,1))
            w$process() # level 1 process with 3 stages
               w$stage() # 1. stage with one state
                  w$state(label="D")
                     w$action(label="A0",weights=c(0,1),prob=c(1,0,0.5,1,1,0.5), end=T)
                     w$action(label="A1",weights=c(0,1),prob=c(2,0,0.5,2,1,0.5))
                        Proc1()
                     w$endAction()
                  w$endState()
               w$endStage()
               w$stage()
                  w$state(label="C0")
                     w$action(label="A0",weights=c(0,0),prob=c(2,0,1))
                        Proc1()
                     w$endAction()
                  w$endState()
                  w$state(label="C1")
                     w$action(label="A0",weights=c(0,1),prob=c(2,0,1))
                        Proc2()
                     w$endAction()
                  w$endState()
               w$endStage()
               w$stage()
                  w$state(label="C0")
                     w$action(label="A0",weights=c(4,1),prob=c(0,0,1))
                     w$endAction()
                  w$endState()
                  w$state(label="C1")
                     w$action(label="A0",weights=c(1,1),prob=c(0,0,1))
                     w$endAction()
                  w$endState()
               w$endStage()
            w$endProcess()
         w$endAction()
      w$endState()
   w$endStage()
w$endProcess()
w$closeWriter()
```

A plot of the HMDP:

```{r plotHMDP, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
prefix<-"hmdp_"
mdpFull<-loadMDP(prefix)

# assign states to grid nodes in the plot
lst<-infoMDP(mdpFull, asStrings = F, withDF = T, withHarc = T)
states<-lst$stateDF
states$label[1]<-'M0'
states$label<-states$sId
states$gId<-NA
getGId<-function(x,y) return((x-1)*gridDim[2]+y)   # grid id given grid coordinates (x=row, y=col)
gridDim<-c(9,12)
for (i in 1:length(states$sId)) {
   if (is.na(states$a0[i])) {
      y<-states$n0[i]*(gridDim[2]-1)+1
      x<-states$s0[i]+1
      #if (states$s0[i]==0) x<-1 else x<-7
   } else  if (is.na(states$a1[i])) {  # at level 1
      y<-ifelse(states$n1[i]==0,2, ifelse(states$n1[i]==1,5,11) )
      x<-states$s1[i]+2
   } else {  # at level 2
      x<-ifelse(states$s1[i]==0, 4, 7)
      y<-ifelse(states$n1[i]==0, 2, 5) + 1
      y<-y+states$n2[i]
      x<-x+states$s2[i]
   }
   states$gId[i]<-getGId(x,y)
}
states<-states[,c('sId','gId','label')]


# assign actions
actions<-lst$harcDF   # an action for each row with head in the first column and the rest tails
colnames(actions)[1]<-"sId"
tmp<-lst$actionDF
actions$label = paste(tmp$label, tmp$w.1, sep=" ") 
actions$lwd<-0.5
actions$lty<-1
actions$col<-"black"
actions$highlight<-F

plotHypergraph(gridDim = gridDim, showGrid = F, devOff = F, states = states, actions = actions )
#dev.copy(pdf,"hmdp.pdf", width=18, height=8)
#dev.off()
```

Note that process 1 is used two places (with different jump actions) and process 2 one place. Now let us generate the HMDP with external processes. First we build the external processes.

```{r proc12}

w<-binaryMDPWriter("proc1_")
w$setWeights(c("Reward","Time"))
Proc1(jumpActions = F)
w$closeWriter()

w<-binaryMDPWriter("proc2_")
w$setWeights(c("Reward","Time"))
Proc2(jumpActions = F)
w$closeWriter()
```

A plot of process 1:

```{r plotProc1, echo=FALSE, results='hide', fig.width=15, fig.height=10}
prefix<-"proc1_"
mdp1<-loadMDP(prefix)

# assign states to grid nodes in the plot
lst<-infoMDP(mdp1, asStrings = F, withDF = T, withHarc = T)
states<-lst$stateDF
states$label<-states$sId
states$gId<-NA
getGId<-function(x,y) return((x-1)*gridDim[2]+y)   # grid id given grid coordinates (x=row, y=col)
gridDim<-c(3,2)
for (i in 1:length(states$sId)) {
   y<-states$n0[i]+1
   x<-states$s0[i]+1
   states$gId[i]<-getGId(x,y)
}
states<-states[,c('sId','gId','label')]

# assign actions
actions<-lst$harcDF   # an action for each row with head in the first column and the rest tails
colnames(actions)[1]<-"sId"
tmp<-lst$actionDF
actions$label = paste(tmp$label, tmp$w.1, sep=" ") 
actions$lwd<-0.5
actions$lty<-1
actions$col<-"black"
actions$highlight<-F
plotHypergraph(gridDim = gridDim, showGrid = F, devOff = F, states = states, actions = actions )
#dev.copy(pdf,"proc1.pdf", width=6, height=6)
#dev.off()
```

A plot of process 2:

```{r plotProc2, echo=FALSE, results='hide', fig.width=12, fig.height=6}
prefix<-"proc2_"
mdp2<-loadMDP(prefix)

# assign states to grid nodes in the plot
lst<-infoMDP(mdp2, asStrings = F, withDF = T, withHarc = T)
states<-lst$stateDF
states$label<-states$sId
states$gId<-NA
getGId<-function(x,y) return((x-1)*gridDim[2]+y)   # grid id given grid coordinates (x=row, y=col)
gridDim<-c(3,5)
for (i in 1:length(states$sId)) {
   y<-states$n0[i]+1
   x<-states$s0[i]+1
   states$gId[i]<-getGId(x,y)
}
states<-states[,c('sId','gId','label')]

# assign actions
actions<-lst$harcDF   # an action for each row with head in the first column and the rest tails
colnames(actions)[1]<-"sId"
tmp<-lst$actionDF
actions$label = paste(tmp$label, tmp$w.1, sep=" ") 
actions$lwd<-0.5
actions$lty<-1
actions$col<-"black"
actions$highlight<-F
plotHypergraph(gridDim = gridDim, showGrid = F, devOff = F, states = states, actions = actions )
#dev.copy(pdf,"proc2.pdf", width=7, height=5)
#dev.off()
```

Next step is to generate the HMDP with external processes:

```{r buildExternal, size="tiny"}
# build the HMDP (without external processes)
prefix<-"ext_"
w<-binaryMDPWriter(prefix)
w$setWeights(c("Reward","Time"))
w$process() # founder process with a single state
   w$stage()
      w$state(label="M0")
         w$action(label="A0",weights=c(0,1),prob=c(2,0,1))
            w$process() # level 1 process with 3 stages
               w$stage() # 1. stage with one state
                  w$state(label="D")
                     w$action(label="A0",weights=c(0,1),prob=c(1,0,0.5,1,1,0.5), end=T)
                        w$includeProcess(prefix="proc1_", label="A1", weights=c(0,1),prob=c(2,0,0.5,2,1,0.5), termStates=3)
                           w$stage()   # last stage in in external process
                              w$state(label="good")       
                                 w$action(label="rep", weights=c(30,1), prob=c(0,0,1), end=TRUE)
                              w$endState()
                              w$state(label="average")     
                                 w$action(label="rep", weights=c(10,1), prob=c(0,0,1), end=TRUE)
                              w$endState()
                              w$state(label="not working") 
                                 w$action(label="rep", weights=c(5,1), prob=c(0,0,1), end=TRUE)
                              w$endState()
                           w$endStage()
                        w$endIncludeProcess()
                  w$endState()
               w$endStage()
               w$stage()
                  w$state(label="C0")
                     w$includeProcess(prefix="proc1_", label="A0",weights=c(0,0),prob=c(2,0,1), termStates=3)
                        w$stage()   # last stage in in external process
                           w$state(label="good")        
                              w$action(label="rep", weights=c(30,1), prob=c(0,0,1), end=TRUE)
                           w$endState()
                           w$state(label="average")     
                              w$action(label="rep", weights=c(10,1), prob=c(0,0,1), end=TRUE)
                           w$endState()
                           w$state(label="not working") 
                              w$action(label="rep", weights=c(5,1), prob=c(0,0,1), end=TRUE)
                           w$endState()
                        w$endStage()
                     w$endIncludeProcess()
                  w$endState()
                  w$state(label="C1")
                     w$includeProcess(prefix="proc2_", label="A0",weights=c(0,1),prob=c(2,0,1), termStates=3)
                        w$stage()   # last stage in in external process
                           w$state(label="good")       
                              w$action(label="rep", weights=c(30,1), prob=c(0,1,1), end=TRUE)
                           w$endState()
                           w$state(label="average")    
                              w$action(label="rep", weights=c(10,1), prob=c(0,1,1), end=TRUE)
                           w$endState()
                           w$state(label="not working") 
                              w$action(label="rep", weights=c(5,1), prob=c(0,1,1), end=TRUE)
                           w$endState()
                        w$endStage()
                     w$endIncludeProcess()
                  w$endState()
               w$endStage()
               w$stage()
                  w$state(label="C0")
                     w$action(label="A0",weights=c(4,1),prob=c(0,0,1))
                     w$endAction()
                  w$endState()
                  w$state(label="C1")
                     w$action(label="A0",weights=c(1,1),prob=c(0,0,1))
                     w$endAction()
                  w$endState()
               w$endStage()
            w$endProcess()
         w$endAction()
      w$endState()
   w$endStage()
w$endProcess()
w$closeWriter()
```

Note the new syntax `includeProcess` which must contain the prefix of the external process and the jump action to the first stage of the external process. Furthermore, the number of states at the last stage of the external process must also be specified. Finally inside the `includeProcess` the last stage of the external process must be included (which must be equal to the process you link to), so that the jump actions back to the father is specified.

Let us have a look at the binary file `ext_externalProcesses.bin` used to indicate that we consider a HMDP with external processes: 

```{r bin}
fileN<-"ext_externalProcesses.bin"
readBin(fileN, character(),n=file.info(fileN)$size)
```

As can be seen each pair specify which stage corresponds to the first stage in the external process and next the prefix of the external process.

Let us have a look at a plot of the HMDP with external processes:

```{r plotExternalHMDP, echo=FALSE, results='hide'}
prefix<-"ext_"
mdpExt<-loadMDP(prefix, verbose = T)

# assign states to grid nodes in the plot
lst<-infoMDP(mdpExt, asStrings = F, withDF = T, withHarc = T)
states<-lst$stateDF
states$label[1]<-'M0'
states$label<-states$sId
states$gId<-NA
getGId<-function(x,y) return((x-1)*gridDim[2]+y)   # grid id given grid coordinates (x=row, y=col)
gridDim<-c(9,12)
for (i in 1:length(states$sId)) {
   if (is.na(states$a0[i])) {
   y<-states$n0[i]*(gridDim[2]-1)+1
      x<-states$s0[i]+1
      #if (states$s0[i]==0) x<-1 else x<-7
   } else  if (is.na(states$a1[i])) {  # at level 1
      y<-ifelse(states$n1[i]==0,2, ifelse(states$n1[i]==1,5,11) )
      x<-states$s1[i]+2
   } else {  # at level 2
      x<-ifelse(states$s1[i]==0, 4, 7)
      y<-ifelse(states$n1[i]==0, 2, 5) + 1
      y<-y+states$n2[i]
      if(states$s1[i]==1 & y==7) y<-10
      x<-x+states$s2[i]
   }
   states$gId[i]<-getGId(x,y)
}
states<-states[,c('sId','gId','label')]

# assign actions
actions<-lst$harcDF   # an action for each row with head in the first column and the rest tails
colnames(actions)[1]<-"sId"
tmp<-lst$actionDF
actions$label = paste(tmp$label, tmp$w.1, sep=" ") 
actions$lwd<-0.5
actions$lty<-1
actions$col<-"black"
actions$highlight<-F

plotHypergraph(gridDim = gridDim, showGrid = F, devOff = F, states = states, actions = actions )
#dev.copy(pdf,"ext.pdf", width=18, height=8)
#dev.off()
```

Note that the states in the first stage of the external process which have a transition from the father is automatically defined. That is, the HMDP with external processes contain first and last stage of the external processes and dummy actions from the first stage to the last stage. Moreover, the states corresponding to the first stage of an external process is automatically given the label corresponding to the stage index:

```{r stageStr}
infoMDP(mdpExt, sId = c(16:17,10,6))$stateDF
```

Let us try to experiment using policy iteration. First we use the full HMDP:

```{r testHMDP}
policyIteAve(mdpFull, "Reward", "Time", maxIte = 100)
getPolicy(mdpFull,c(27,26,25,20,19,5:13))
```

Now let us try to solve the same model using external processes:

```{r testExt}
g<-policyIteAve(mdpExt, "Reward", "Time", maxIte = 5)
getPolicy(mdpExt,c(18))
```

Note that memory of the external processes is allocated and deallocated when needed. Indeed since process 1 is used two times in a row a reallocation is not done. Note that you are only able to get the optimal policy of the loaded HMDP. However, if we want to get the optimal policy of the external processes we can do that by loading the processes and assigning rewards of the last stage as the terminal rewards:

```{r policyExt}
# process 1 optimal policy - external at stage "0,0,0,0,0,1,0"
lastStage<-"0,0,0,0,0,1,1"
termValues <- getPolicy(mdpExt, stageStr = lastStage)$reward
valueIte(mdp1, 'Reward', 'Time', termValues=termValues, g=g)
getPolicy(mdp1,c(3,4))

# process 1 optimal policy - external at stage "0,0,0,1,0,0,0"
lastStage<-"0,0,0,1,0,0,1"
termValues <- getPolicy(mdpExt, stageStr = lastStage)$reward
valueIte(mdp1, 'Reward', 'Time', termValues=termValues, g=g)
getPolicy(mdp1,c(3,4))

# process 2 optimal policy - external at stage "0,0,0,1,1,0,0"
lastStage<-"0,0,0,1,1,0,1"
termValues <- getPolicy(mdpExt, stageStr = lastStage)$reward
valueIte(mdp2, 'Reward', 'Time', termValues=termValues, g=g)
getPolicy(mdp2,c(3:10))
```

Some assumtions that must hold:

* External processes must use the standard names of the binary files with a given prefix.
* External processes must be defined with the same weight labels.
